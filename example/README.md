# Example CTF Submission

This is one of the vulnerable contracts of RACE-26. The vulnerability is that the `@nonreentrant("withdraw")` locks are not synchronized due to compiler bug in `vyper 0.3.0`. This allows an attacker to drain the vault through [cross-contract reentrancy](https://inspexco.medium.com/cross-contract-reentrancy-attack-402d27a02a15). Thus, to compile the contract, we need to use `vyper 0.3.0`, so if we have `python3.9` intalled, we must initialize an appropriate virtual environment and install the necessary dependencies:

```bash
python3.9 -m venv example-python-env
source example-python-env/bin/activate
python3.9 -m pip install -r requirements.txt
```

## Structure

This submission uses Foundry as the framework. You will see that there are several workarounds to make it work with Vyper. First (assuming you have Foundry installed), we'll install the dependencies:
    
```bash
forge install
```

The vulnerable contract is [`ExampleCTFVy.vy`](src/ExampleCTFVy.vy) and the solution is in [`ExampleCTFSolutionVy.vy`](src/ExampleCTFVySolution.sol). The [`script`](script) folder contains the scripts to deploy the contracts.

## Testing the challenge

The `ExampleCTFTest.t.sol` checks that the challenge is vulnerable and that the solution works. The test itself uses the scripts in the [`script`](script) folder. The test can be run with:

```bash
forge test
```

_(Remember to add `-vvvvv` to see the complete trace if you're interested)_

## Deploying the challenge

Deploying vyper contracts is a bit tricky. We'll need to create an `.env` file that contains the rpc url and the deployer private key (see [`example.env`](example.env)).

The `script/ExampleCTFOnchainDeployer.sh` contains a partial instruction used as a workaround to deploy the contract, which uses the `vyper` compiler to compile the contract and then uses `cast` to deploy the generated bytecode. The script can be run with:

```bash
eval "$(cat script/ExampleCTFOnchainDeployer.sh <(vyper src/ExampleCTFVy.vy))"
```

### Funding the contract

This challenge requires that someone deposits ether to it. We'll be depositing 1 ether to the contract. This can be done with:

```bash
cast send [CTF_address] "deposit()" --value "1ether" --private-key $PRIVATE_KEY --rpc-url $RPC_URL
```

_(where `[CTF_address]` is the address of our CTF contract)._

This concludes our setup. We can now test that the contract is vulnerable by calling the `isSolved` function:

```bash
cast call [CTF_address] "isSolved()(bool)" --rpc-url $RPC_URL
```

which should return `false`.

## Deploying the Solution contract

When solving others' challenges, **do it locally**, else you'd be spoiling other's fun. To do so, in Foundry, you can fork the blockchain with:

```bash
anvil --fork-url $RPC_URL
```

and then use the forked blockchain by using `http://localhost:8545` as $RPC_URL down the line.

It is very important to check that calling `isSolved` returns `false` before deploying the solution contract. If it doesn't, that means someone solved it onchain by mistake.

In this particular case, given that the solution is written in Solidity, we can re-use the scripts used in the test to deploy the solution. The script can be run with:

```bash
forge script script/ExampleCTFSolutionDeployer.s.sol --broadcast --private-key $PRIVATE_KEY --rpc-url http://localhost:8545 --sig "run(address)" [CTF_address] --broadcast
```

### Solving the challenge

We can now solve the challenge by calling the `solve` function of the solution contract (remember, it requires 0.1 ether to be sent to it):

```bash
cast send [solution_address] "solve()" --private-key $PRIVATE_KEY --rpc-url http://localhost:8545 --value "0.1ether"
```

_(where `[solution_address]` is the address of our solution contract)._

### Verifying the solution

We can verify that the challenge is solved by calling the `isSolved` function of the challenge:

```bash
cast call [CTF_address] "isSolved()" --rpc-url http://localhost:8545
```

which should return `true`.

